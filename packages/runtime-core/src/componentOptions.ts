import { ComputedGetter, WritableComputedOptions } from '@docue/reactivity'
import {
  CreateComponentPublicInstance,
  IntersectionMixin,
  UnwrapMixinsType
} from './componentPublicInstance'
import {
  ComponentInternalOptions,
  ConcreteComponent,
  SetupContext
} from './component'
import { VNodeChild } from './vnode'
import { LooseRequired, Prettify } from '@docue/shared'
import { SlotsType } from './componentSlots'
import { EmitsOptions, EmitsToProps } from './componentEmits'
import {
  ComponentObjectPropsOptions,
  ExtractDefaultPropTypes,
  ExtractPropTypes
} from './componentProps'

/**
 * Interface for declaring custom options.
 *
 * @example
 * ```ts
 * declare module '@vue/runtime-core' {
 *   interface ComponentCustomOptions {
 *     beforeRouteUpdate?(
 *       to: Route,
 *       from: Route,
 *       next: () => void
 *     ): void
 *   }
 * }
 * ```
 */
export interface ComponentCustomOptions {}

export type RenderFunction = () => VNodeChild

export interface ComponentOptionsBase<
  Props,
  RawBindings,
  D,
  C extends ComputedOptions,
  M extends MethodOptions,
  Mixin extends ComponentOptionsMixin,
  Extends extends ComponentOptionsMixin,
  E extends EmitsOptions,
  EE extends string = string,
  Defaults = {},
  I extends ComponentInjectOptions = {},
  II extends string = string,
  S extends SlotsType = {}
> extends ComponentInternalOptions,
    ComponentCustomOptions {
  setup?: (
    this: void,
    props: LooseRequired<
      Props &
        Prettify<
          UnwrapMixinsType<
            IntersectionMixin<Mixin> & IntersectionMixin<Extends>,
            'P'
          >
        >
    >,
    ctx: SetupContext<E, S>
  ) => Promise<RawBindings> | RawBindings | RenderFunction | void
  name?: string
  template?: string | object // can be a direct DOM node
  // Note: we are intentionally using the signature-less `Function` type here
  // since any type with signature will cause the whole inference to fail when
  // the return expression contains reference to `this`.
  // Luckily `render()` doesn't need any arguments nor does it care about return
  // type.
  render?: Function
  // components?: Record<string, Component>
  // directives?: Record<string, Directive>
  inheritAttrs?: boolean
  emits?: (E | EE[]) & ThisType<void>
  slots?: S
  // TODO infer public instance type based on exposed keys
  expose?: string[]
  serverPrefetch?(): void | Promise<any>

  // // Runtime compiler only -----------------------------------------------------
  // compilerOptions?: RuntimeCompilerOptions

  // // Internal ------------------------------------------------------------------

  // /**
  //  * SSR only. This is produced by compiler-ssr and attached in compiler-sfc
  //  * not user facing, so the typing is lax and for test only.
  //  * @internal
  //  */
  // ssrRender?: (
  //   ctx: any,
  //   push: (item: any) => void,
  //   parentInstance: ComponentInternalInstance,
  //   attrs: Data | undefined,
  //   // for compiler-optimized bindings
  //   $props: ComponentInternalInstance['props'],
  //   $setup: ComponentInternalInstance['setupState'],
  //   $data: ComponentInternalInstance['data'],
  //   $options: ComponentInternalInstance['ctx']
  // ) => void

  // /**
  //  * Only generated by compiler-sfc to mark a ssr render function inlined and
  //  * returned from setup()
  //  * @internal
  //  */
  // __ssrInlineRender?: boolean

  // /**
  //  * marker for AsyncComponentWrapper
  //  * @internal
  //  */
  // __asyncLoader?: () => Promise<ConcreteComponent>
  // /**
  //  * the inner component resolved by the AsyncComponentWrapper
  //  * @internal
  //  */
  // __asyncResolved?: ConcreteComponent

  // // Type differentiators ------------------------------------------------------

  // // Note these are internal but need to be exposed in d.ts for type inference
  // // to work!

  // // type-only differentiator to separate OptionWithoutProps from a constructor
  // // type returned by defineComponent() or FunctionalComponent
  // call?: (this: unknown, ...args: unknown[]) => never
  // // type-only differentiators for built-in Vnode types
  // __isFragment?: never
  // __isTeleport?: never
  // __isSuspense?: never

  // __defaults?: Defaults
}

export type ComponentOptionsWithObjectProps<
  PropsOptions = ComponentObjectPropsOptions,
  RawBindings = {},
  D = {},
  C extends ComputedOptions = {},
  M extends MethodOptions = {},
  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,
  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,
  E extends EmitsOptions = EmitsOptions,
  EE extends string = string,
  I extends ComponentInjectOptions = {},
  II extends string = string,
  S extends SlotsType = {},
  Props = Prettify<Readonly<ExtractPropTypes<PropsOptions> & EmitsToProps<E>>>,
  Defaults = ExtractDefaultPropTypes<PropsOptions>
> = ComponentOptionsBase<
  Props,
  RawBindings,
  D,
  C,
  M,
  Mixin,
  Extends,
  E,
  EE,
  Defaults,
  I,
  II,
  S
> & {
  props: PropsOptions & ThisType<void>
} & ThisType<
    CreateComponentPublicInstance<
      Props,
      RawBindings,
      D,
      C,
      M,
      Mixin,
      Extends,
      E,
      Props,
      Defaults,
      false,
      I,
      S
    >
  >

export type ComponentOptions<
  Props = {},
  RawBindings = any,
  D = any,
  C extends ComputedOptions = any,
  M extends MethodOptions = any,
  Mixin extends ComponentOptionsMixin = any,
  Extends extends ComponentOptionsMixin = any,
  E extends EmitsOptions = any,
  S extends SlotsType = any
> = ComponentOptionsBase<
  Props,
  RawBindings,
  D,
  C,
  M,
  Mixin,
  Extends,
  E,
  string,
  S
> &
  ThisType<CreateComponentPublicInstance<{}, RawBindings, D, C, M>>

export type ComponentOptionsMixin = ComponentOptionsBase<
  any,
  any,
  any,
  any,
  any,
  any,
  any,
  any,
  any,
  any,
  any
>

export type ComputedOptions = Record<
  string,
  ComputedGetter<any> | WritableComputedOptions<any>
>

export interface MethodOptions {
  [key: string]: Function
}

export type ComponentInjectOptions = string[] | ObjectInjectOptions

export type ObjectInjectOptions = Record<
  string | symbol,
  string | symbol | { from?: string | symbol; default?: unknown }
>

export type InjectToObject<T extends ComponentInjectOptions> =
  T extends string[]
    ? {
        [K in T[number]]?: unknown
      }
    : T extends ObjectInjectOptions
    ? {
        [K in keyof T]?: unknown
      }
    : never

export type OptionTypesKeys = 'P' | 'B' | 'D' | 'C' | 'M' | 'Defaults'

export type OptionTypesType<
  P = {},
  B = {},
  D = {},
  C extends ComputedOptions = {},
  M extends MethodOptions = {},
  Defaults = {}
> = {
  P: P
  B: B
  D: D
  C: C
  M: M
  Defaults: Defaults
}
